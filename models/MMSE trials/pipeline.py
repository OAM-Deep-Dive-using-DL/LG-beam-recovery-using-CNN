"""
Complete End-to-End FSO-OAM Communication System (Rectified)
Integrates: Transmitter -> Channel (Physics) -> Receiver (Digital)

SIMULATION METHOD:
==================
This simulation uses the "quasi-static" channel assumption, which is
standard for FSO systems where the atmosphere coherence time (ms)
is much longer than a symbol duration (ns).

1.  TX: A full frame of data (e.g., 4096 bits -> 3414 symbols) 
    is generated by the transmitter (`encodingRunner`).
2.  CHANNEL (Physics):
    -   One "snapshot" of the turbulent atmosphere is created 
        (one set of phase screens).
    -   The simulation then loops, processing ONE symbol at a time.
    -   For each symbol, it creates the multiplexed field, propagates
        it through the *same* frozen atmosphere, and stores the
        final received 2D field.
    -   This creates a *sequence* of received fields, one for
        each symbol.
3.  RX:
    -   The full sequence of received fields is passed to `FSORx`.
    -   The receiver projects *each field* to get a symbol,
        building a sequence of received symbols.
    -   It uses the PILOTS in this sequence to estimate the
        channel matrix (H_est).
    -   It equalizes the DATA symbols, decodes, and 
        calculates the final Bit Error Rate (BER).
"""

import os
import sys

try:
    SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
except NameError:
    SCRIPT_DIR = os.getcwd()
sys.path.insert(0, SCRIPT_DIR)

import numpy as np
import matplotlib.pyplot as plt
from scipy.fft import fft2, ifft2
import warnings
warnings.filterwarnings('ignore')

# Import all modules
try:
    from lgBeam import LaguerreGaussianBeam
    from encoding import encodingRunner, QPSKModulator, SimplifiedLDPC, PilotHandler
    from fsplAtmAttenuation import calculate_kim_attenuation, calculate_geometric_loss
    
    from turbulence import (AtmosphericTurbulence, 
                            create_multi_layer_screens,
                            apply_multi_layer_turbulence)
    from receiver import FSORx
except ImportError as e:
    print(f"✗ E2E Simulation Import Error: {e}")
    print("  Please ensure lgBeam.py, encoding.py, turbulence.py, ")
    print("  fsplAtmAttenuation.py, and receiver.py are all in the same directory.")
    sys.exit(1)

np.random.seed(42)

# ============================================================================
# GLOBAL SYSTEM CONFIGURATION
# ============================================================================
class SimulationConfig:
    """
    Centralized configuration for a realistic FSO-OAM system 
    for research purposes.
    """
    # --- Optical Parameters ---
    WAVELENGTH = 1550e-9  # [m]
    W0 = 25e-3           # [m]
    
    # --- Link Parameters ---
    DISTANCE = 1200      # [m]
    RECEIVER_DIAMETER = 0.3  # [m]
    P_TX_TOTAL_W = 1.0     # [W]
    
    # --- Spatial Modes ---
    SPATIAL_MODES = [(0, -1), (0, 1), (0, -3), (0, 3), (0, -4), (0, 4)]
    
    # --- Turbulence Parameters (TRUE IDEAL) ---
    CN2 = 1e-20          # [m^(-2/3)] 
    L0 = 10.0           # [m]
    L0_INNER = 0.005    # [m]
    NUM_SCREENS = 5   
    
    # --- Weather Condition ---
    WEATHER = 'clear'    
    
    # --- Communication Parameters (TRUE IDEAL) ---
    FEC_RATE = 0.8      
    PILOT_RATIO = 0.1   
    

    N_INFO_BITS = 4095  # 4095 bits
    
    # --- Simulation Grid ---
    N_GRID = 512        # 512x512 is fast for a sanity check
    OVERSAMPLING = 2    
    
    # --- Receiver Configuration (TRUE IDEAL) ---   
    ADD_NOISE = False   # Disable additive noise
    SNR_DB = 99         # Set to a high dummy value
    
    # --- Output ---
    PLOT_DIR = os.path.join(SCRIPT_DIR, "e2e_results_ideal") # New folder
    DPI = 300


# ============================================================================
# NEW E2E SIMULATION (RECTIFIED)
# ============================================================================

def run_e2e_simulation(config):
    """
    Runs the complete, rectified E2E simulation.
    
    This implementation is physically correct AND compatible with all
    your existing files.
    """
    
    # === 1. INITIALIZATION ===
    print("\n" + "="*80)
    print("INITIALIZING E2E SIMULATION")
    print("="*80)
    
    cfg = config
    n_modes = len(cfg.SPATIAL_MODES)

    # 1a. Initialize Transmitter
    print("[1] Initializing Transmitter...")
    transmitter = encodingRunner(
        spatial_modes=cfg.SPATIAL_MODES,
        wavelength=cfg.WAVELENGTH,
        w0=cfg.W0,
        fec_rate=cfg.FEC_RATE,
        pilot_ratio=cfg.PILOT_RATIO
    )
    
    # 1b. Initialize Turbulence Model
    print("[2] Initializing Channel Models...")
    turbulence = AtmosphericTurbulence(
        Cn2=cfg.CN2, L0=cfg.L0, l0=cfg.L0_INNER, wavelength=cfg.WAVELENGTH
    )

    # 1c. Initialize Simulation Grid
    print("[3] Initializing Simulation Grid...")
    max_m2_beam = max(transmitter.lg_beams.values(), key=lambda b: b.M_squared)
    beam_size_at_rx = max_m2_beam.beam_waist(cfg.DISTANCE)
    
    D = cfg.OVERSAMPLING * 6 * beam_size_at_rx
    delta = D / cfg.N_GRID
    
    x = np.linspace(-D/2, D/2, cfg.N_GRID)
    y = np.linspace(-D/2, D/2, cfg.N_GRID)
    X, Y = np.meshgrid(x, y, indexing='ij')
    R = np.sqrt(X**2 + Y**2)
    PHI = np.arctan2(Y, X)
    
    grid_info = {
        'x': x, 'y': y, 'X': X, 'Y': Y, 'R': R, 'PHI': PHI,
        'D': D, 'delta': delta, 'N': cfg.N_GRID
    }
    print(f"    Grid sized for: LG_p={max_m2_beam.p}, l={max_m2_beam.l} (M²={max_m2_beam.M_squared:.1f})")
    print(f"    Grid resolution: {cfg.N_GRID}x{cfg.N_GRID}, Pixel: {delta*1000:.2f} mm")

    # 1d. Generate Basis Fields (at z=0)
    print("[4] Generating Basis Mode Fields (at z=0)...")
    tx_basis_fields = {}
    for mode_key, beam in transmitter.lg_beams.items():
        tx_basis_fields[mode_key] = beam.generate_beam_field(R, PHI, 0)
        
    # 1e. Initialize Receiver
    print("[5] Initializing Receiver...")
    receiver = FSORx(
        spatial_modes=cfg.SPATIAL_MODES,
        wavelength=cfg.WAVELENGTH,
        w0=cfg.W0,
        z_distance=cfg.DISTANCE,
        fec_rate=cfg.FEC_RATE,
        pilot_handler=transmitter.pilot_handler,  # Share pilot handler!
        receiver_radius=(cfg.RECEIVER_DIAMETER / 2.0),
        ldpc_instance=transmitter.ldpc  # CRITICAL: Share LDPC instance to ensure same H matrix!
    )

    # === 2. TRANSMITTER ===
    print("\n" + "="*80)
    print("STAGE 1: TRANSMITTER")
    print("="*80)
    
    # Generate original data bits
    data_bits = np.random.randint(0, 2, cfg.N_INFO_BITS)
    print(f"Generated {len(data_bits)} info bits.")
    
    # Generate the full frame of symbols
    tx_signals = transmitter.transmit(data_bits, verbose=True)
    
    # Get total number of symbols. Find the *minimum* length across all modes.
    symbol_lengths = [sig['n_symbols'] for sig in tx_signals.values()]
    if not symbol_lengths or min(symbol_lengths) == 0:
         print("✗ ERROR: Transmitter produced 0 symbols.")
         return None
         
    n_symbols = min(symbol_lengths)
    print(f"    (Simulation will truncate to minimum frame length: {n_symbols} symbols)")

    # === 3. PHYSICAL CHANNEL ===
    print("\n" + "="*80)
    print("STAGE 2: PHYSICAL CHANNEL (QUASI-STATIC)")
    print("="*80)
    
    # 3a. Create one "frozen" snapshot of the atmosphere
    print(f"[1] Generating {cfg.NUM_SCREENS} phase screens for one channel snapshot...")
    layers = create_multi_layer_screens(
        cfg.DISTANCE, cfg.NUM_SCREENS, 
        cfg.WAVELENGTH, cfg.CN2, 
        cfg.L0, cfg.L0_INNER, verbose=False
    )
    print(f"    Generated {len(layers)} screen layers.")
    
    # 3b. Calculate Attenuation Loss
    print("[2] Calculating Attenuation...")
    w_z_analytical = max_m2_beam.beam_waist(cfg.DISTANCE)
    L_geo_dB, eta_geo = calculate_geometric_loss(w_z_analytical, cfg.RECEIVER_DIAMETER / 2.0)
    
    # Use 23km visibility for 'clear'
    visibility_km = 23.0 
    alpha_dBkm = calculate_kim_attenuation(cfg.WAVELENGTH * 1e9, visibility_km)
    L_atm_dB = alpha_dBkm * (cfg.DISTANCE / 1000.0)
    
    amplitude_loss = 10**(-L_atm_dB / 20.0) # Apply attenuation
    
    print(f"    Atmospheric Loss: {L_atm_dB:.2f} dB (Amplitude factor: {amplitude_loss:.3f})")
    print(f"    Geometric Loss (Analytical): {L_geo_dB:.2f} dB (Collection Eff: {eta_geo*100:.1f}%)")
    
    # 3c. Calculate Noise
    print("[3] Calculating Noise Parameters...")
    aperture_mask = (grid_info['R'] <= cfg.RECEIVER_DIAMETER / 2.0).astype(float)
    dA = grid_info['delta']**2
    
    if cfg.ADD_NOISE:
        # Estimate received power by propagating a "1" on all modes
        E_tx_power_probe = np.zeros((cfg.N_GRID, cfg.N_GRID), dtype=complex)
        for mode_key in cfg.SPATIAL_MODES:
            E_tx_power_probe += tx_basis_fields[mode_key]
            
        result = apply_multi_layer_turbulence(
            initial_field=E_tx_power_probe,
            base_beam=max_m2_beam, layers=layers, total_distance=cfg.DISTANCE,
            N=cfg.N_GRID, oversampling=cfg.OVERSAMPLING,
            L0=cfg.L0, l0=cfg.L0_INNER
        )
        E_rx_power_probe = result['final_field']
        
        # Apply attenuation and aperture
        E_rx_power_probe = E_rx_power_probe * amplitude_loss * aperture_mask
        
        # This is the total power for M symbols of '1'
        avg_signal_power_total = np.sum(np.abs(E_rx_power_probe)**2) * dA
        # Average signal power per mode
        avg_signal_power_per_mode = avg_signal_power_total / n_modes
        
        snr_linear = 10**(cfg.SNR_DB / 10.0)
        noise_power_per_mode = avg_signal_power_per_mode / snr_linear
        
        # Let's find the average intensity *per pixel* inside the aperture
        num_pixels_in_aperture = np.sum(aperture_mask)
        if num_pixels_in_aperture == 0: num_pixels_in_aperture = 1
        
        avg_pixel_intensity = np.sum(np.abs(E_rx_power_probe)**2) / num_pixels_in_aperture
        
        # Define noise variance *per pixel* relative to this
        noise_var_per_pixel = avg_pixel_intensity / snr_linear 
        noise_std_per_pixel = np.sqrt(noise_var_per_pixel)
        
        print(f"    Target SNR: {cfg.SNR_DB} dB")
        print(f"    Avg. Signal Intensity (in aperture): {avg_pixel_intensity:.2e}")
        print(f"    Noise Variance (per pixel): {noise_var_per_pixel:.2e}")
    else:
        print("    Noise disabled.")
        noise_std_per_pixel = 0.0

    # 3d. Loop over all symbols (PHYSICAL PROPAGATION)
    print(f"[4] Propagating {n_symbols} symbols through channel... (This is slow!)")
    
    E_rx_sequence = [] # This will store the list of 2D fields
    
    for sym_idx in range(n_symbols): # Loop to the *minimum* length
        # 1. Create the multiplexed field for this symbol
        E_tx_symbol = np.zeros((cfg.N_GRID, cfg.N_GRID), dtype=complex)
        for mode_key in cfg.SPATIAL_MODES:
            # All modes are guaranteed to have at least 'n_symbols'
            symbol = tx_signals[mode_key]['symbols'][sym_idx]
            E_tx_symbol += tx_basis_fields[mode_key] * symbol
            
        # 2. Propagate the *combined* field
        result = apply_multi_layer_turbulence(
            initial_field=E_tx_symbol,
            base_beam=max_m2_beam, layers=layers, total_distance=cfg.DISTANCE,
            N=cfg.N_GRID, oversampling=cfg.OVERSAMPLING,
            L0=cfg.L0, l0=cfg.L0_INNER
        )
        E_rx_turbulent = result['final_field']
        
        # 3. Apply Attenuation
        E_rx_attenuated = E_rx_turbulent * amplitude_loss
        
        # 4. Add Noise
        if cfg.ADD_NOISE:
            noise = (noise_std_per_pixel / np.sqrt(2)) * (
                np.random.randn(cfg.N_GRID, cfg.N_GRID) + 
                1j * np.random.randn(cfg.N_GRID, cfg.N_GRID)
            )
            E_rx_final = E_rx_attenuated + noise
        else:
            E_rx_final = E_rx_attenuated
            
        # 5. Apply Aperture (at the very end)
        E_rx_final = E_rx_final * aperture_mask
        
        # 6. Store the final field
        E_rx_sequence.append(E_rx_final)
        
        if (sym_idx + 1) % 50 == 0 or sym_idx == n_symbols - 1:
            print(f"    ... propagated symbol {sym_idx + 1}/{n_symbols}")
            
    print("    ✓ Full frame propagated.")
    
    # Store one field for visualization
    E_rx_visualization = E_rx_sequence[0] 

    # === 4. RECEIVER ===
    print("\n" + "="*80)
    print("STAGE 3: DIGITAL RECEIVER")
    print("="*80)
    
    # CRITICAL: Truncate tx_signals to match the actual propagated length
    # The pipeline only propagates n_symbols symbols per mode
    tx_signals_truncated = {}
    for mode_key in cfg.SPATIAL_MODES:
        tx_signals_truncated[mode_key] = {
            'symbols': tx_signals[mode_key]['symbols'][:n_symbols],
            'beam': tx_signals[mode_key]['beam'],
            'n_symbols': n_symbols
        }
    
    # Pass the *entire sequence of fields* to the receiver
    recovered_bits, metrics = receiver.receive_sequence(
        E_rx_sequence=E_rx_sequence,
        grid_info=grid_info,
        tx_signals=tx_signals_truncated,
        original_data_bits=data_bits,
        verbose=True
    )

    # === 5. RESULTS ===
    print("\n" + "="*80)
    print("E2E SIMULATION COMPLETE - FINAL RESULTS")
    print("="*80)
    print(f"    TURBULENCE: Cn² = {cfg.CN2:.2e} (m^-2/3)")
    print(f"    LINK: {cfg.DISTANCE} m, {cfg.NUM_SCREENS} screens")
    print(f"    SNR: {cfg.SNR_DB} dB")
    print(f"    EQUALIZER: MMSE")
    print(f"    -----------------------------------")
    print(f"    TOTAL INFO BITS: {metrics['total_bits']}")
    print(f"    BIT ERRORS:      {metrics['bit_errors']}")
    print(f"    FINAL BER:       {metrics['ber']:.4e}")
    print("="*80)
    
    # Store results for plotting
    results = {
        'config': cfg,
        'metrics': metrics,
        'grid_info': grid_info,
        'tx_signals': tx_signals,
        'E_tx_visualization': tx_basis_fields[cfg.SPATIAL_MODES[0]], # Just show one mode
        'E_rx_visualization': E_rx_visualization,
        'H_est': metrics['H_est']
    }
    
    return results

def plot_e2e_results(results, save_path=None):
    """
    Plot the summary of the E2E simulation.
    """
    print("Generating E2E results plot...")
    
    cfg = results['config']
    metrics = results['metrics']
    grid_info = results['grid_info']
    H_est = metrics['H_est']
    
    fig = plt.figure(figsize=(20, 12))
    gs = fig.add_gridspec(2, 3)
    
    fig.suptitle(f"End-to-End FSO-OAM Simulation Results\n"
                 f"Cn²={cfg.CN2:.1e}, L={cfg.DISTANCE}m, SNR={cfg.SNR_DB}dB, BER={metrics['ber']:.2e}",
                 fontsize=18, fontweight='bold')
    
    extent_mm = grid_info['D'] * 1e3 / 2
    
    # Plot 1: Transmitted field (example)
    ax1 = fig.add_subplot(gs[0, 0])
    E_tx_vis = np.abs(results['E_tx_visualization'])**2
    im1 = ax1.imshow(E_tx_vis.T, 
                    extent=[-extent_mm, extent_mm, -extent_mm, extent_mm],
                    cmap='hot', origin='lower')
    ax1.set_title(f'TX Basis Mode Example\n(p,l)={cfg.SPATIAL_MODES[0]}', fontweight='bold')
    ax1.set_xlabel('x [mm]')
    ax1.set_ylabel('y [mm]')
    plt.colorbar(im1, ax=ax1, label='Intensity')
    
    # Plot 2: Received field (example snapshot)
    ax2 = fig.add_subplot(gs[1, 0])
    E_rx_vis = np.abs(results['E_rx_visualization'])**2
    vmax = np.percentile(E_rx_vis, 99.9) # Clip hotspots for better viz
    im2 = ax2.imshow(E_rx_vis.T, 
                    extent=[-extent_mm, extent_mm, -extent_mm, extent_mm],
                    cmap='hot', origin='lower', vmax=vmax)
    ax2.set_title(f'RX Field Snapshot (Symbol 0)', fontweight='bold')
    ax2.set_xlabel('x [mm]')
    ax2.set_ylabel('y [mm]')
    plt.colorbar(im2, ax=ax2, label='Intensity')
    
    # Plot 3: Estimated Channel Matrix |H_est|
    ax3 = fig.add_subplot(gs[0, 1])
    im3 = ax3.imshow(np.abs(H_est), cmap='viridis', interpolation='nearest')
    ax3.set_title(r'Estimated Channel Matrix $|\hat{H}|$', fontweight='bold')
    
    mode_labels = [f"({p},{l})" for p,l in cfg.SPATIAL_MODES]
    ax3.set_xticks(np.arange(len(mode_labels)))
    ax3.set_yticks(np.arange(len(mode_labels)))
    ax3.set_xticklabels(mode_labels, rotation=45, ha='right')
    ax3.set_yticklabels(mode_labels)
    ax3.set_xlabel('Transmitted Mode (j)')
    ax3.set_ylabel('Received Mode (i)')
    plt.colorbar(im3, ax=ax3, label='Magnitude (Coupling Strength)')
    # Add text labels
    for i in range(H_est.shape[0]):
        for j in range(H_est.shape[1]):
            ax3.text(j, i, f"{np.abs(H_est[i,j]):.2f}", 
                     ha="center", va="center", color="w", fontsize=8)
            
    # Plot 4: Channel Matrix Phase
    ax4 = fig.add_subplot(gs[1, 1])
    im4 = ax4.imshow(np.angle(H_est), cmap='hsv', interpolation='nearest', vmin=-np.pi, vmax=np.pi)
    ax4.set_title(r'Estimated Channel Matrix Phase $\angle \hat{H}$', fontweight='bold')
    ax4.set_xticks(np.arange(len(mode_labels)))
    ax4.set_yticks(np.arange(len(mode_labels)))
    ax4.set_xticklabels(mode_labels, rotation=45, ha='right')
    ax4.set_yticklabels(mode_labels)
    ax4.set_xlabel('Transmitted Mode (j)')
    ax4.set_ylabel('Received Mode (i)')
    plt.colorbar(im4, ax=ax4, label='Phase (rad)')
    
    # Plot 5: Performance Metrics Text
    ax5 = fig.add_subplot(gs[:, 2])
    ax5.axis('off')
    
    # Get turbulence properties
    temp_turb = AtmosphericTurbulence(
        Cn2=cfg.CN2, L0=cfg.L0, l0=cfg.L0_INNER, wavelength=cfg.WAVELENGTH
    )
    
    metrics_text = f"""
SYSTEM PERFORMANCE METRICS

[Link Parameters]
  Distance: {cfg.DISTANCE} m
  Weather: {cfg.WEATHER}
  Turbulence: Cn² = {cfg.CN2:.2e}
  SNR: {cfg.SNR_DB} dB
  Modes: {len(cfg.SPATIAL_MODES)} ( {', '.join(mode_labels)} )

[Channel Metrics]
  Rytov Variance: {temp_turb.rytov_variance(cfg.DISTANCE):.3f}
  Fried Parameter (r0): {temp_turb.fried_parameter(cfg.DISTANCE)*1000:.2f} mm
  Channel Condition: {np.linalg.cond(H_est):.2f}
  
[Receiver Metrics]
  Equalization: MMSE
  Est. Noise Var: {metrics['noise_var']:.2e}

[FINAL PERFORMANCE]
  Total Info Bits: {metrics['total_bits']}
  Bit Errors: {metrics['bit_errors']}
  ---------------------------------
  Bit Error Rate (BER): {metrics['ber']:.4e}
  ---------------------------------
    """
    
    ax5.text(0.0, 0.95, metrics_text, transform=ax5.transAxes,
            fontsize=12, verticalalignment='top', fontfamily='monospace',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.3))

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    
    if save_path:
        # Ensure the directory exists before trying to save the file
        plot_directory = os.path.dirname(save_path)
        os.makedirs(plot_directory, exist_ok=True)
        
        plt.savefig(save_path, dpi=cfg.DPI, bbox_inches='tight')
        print(f"\n✓ E2E Results plot saved to: {save_path}")
    
    return fig


# ============================================================================
# MAIN EXECUTION
# ============================================================================

if __name__ == "__main__":
    
    # 1. Initialize Configuration
    config = SimulationConfig()
    
    # --- Override config here for quick tests ---
    #config.CN2 = 1e-20
    #config.SNR_DB = 99
    #config.N_GRID = 512
    #config.NUM_SCREENS = 5
    #config.N_INFO_BITS = 819 
    
    # 2. Run end-to-end simulation
    results = run_e2e_simulation(config)
    
    # 3. Plot results
    if results:
        save_file = os.path.join(config.PLOT_DIR, "e2e_simulation_results.png")
        fig = plot_e2e_results(results, save_path=save_file)
        plt.show()
    else:
        print("✗ Simulation failed to produce results.")